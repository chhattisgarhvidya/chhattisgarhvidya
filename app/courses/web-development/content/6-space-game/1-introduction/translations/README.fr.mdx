---
title: DÃ©veloppez un jeu spatial, partie 1: Introduction
description: No description available
lastUpdated: 2024-12-21T06:11:55.002Z
---

# DÃ©veloppez un jeu spatial, partie 1: Introduction

![video](../../images/pewpew.gif)

## Quiz prÃ©alable

[Quiz prÃ©alable](https://ashy-river-0debb7803.1.azurestaticapps.net/quiz/29?loc=fr)

### HÃ©ritage et composition dans le dÃ©veloppement de jeux

ans les leÃ§ons prÃ©cÃ©dentes, il n'y avait pas vraiment besoin de s'inquiÃ©ter de l'architecture de conception des applications que vous avez crÃ©Ã©es, car les projets Ã©taient de trÃ¨s petite portÃ©e. Cependant, lorsque vos applications augmentent en taille et en Ã©tendue, les dÃ©cisions architecturales deviennent une prÃ©occupation plus importante. Il existe deux approches principales pour crÃ©er des applications plus volumineuses en JavaScript: la *composition* ou l'*hÃ©ritage*. Il y a des avantages et des inconvÃ©nients dans les deux cas, mais expliquons-les dans le contexte d'un jeu.

âœ… L'un des livres de programmation les plus cÃ©lÃ¨bres jamais Ã©crits concerne les [modÃ¨les de conception](https://en.wikipedia.org/wiki/Design_Patterns).

Dans un jeu, vous avez des `game objects` qui sont des objets qui existent sur un Ã©cran. Cela signifie qu'ils ont un emplacement sur un systÃ¨me de coordonnÃ©es cartÃ©sien, caractÃ©risÃ© par une coordonnÃ©e `x` et `y`. Au fur et Ã  mesure que vous dÃ©veloppez un jeu, vous remarquerez que tous vos objets de jeu ont une propriÃ©tÃ© standard, commune Ã  chaque jeu que vous crÃ©ez, Ã  savoir des Ã©lÃ©ments qui sont:

- **location-based** La plupart des Ã©lÃ©ments de jeu, sinon tous, sont basÃ©s sur l'emplacement. Cela signifie qu'ils ont un emplacement, un `x` et un `y`.
- **movable** Ce sont des objets qui peuvent se dÃ©placer vers un nouvel emplacement. Il s'agit gÃ©nÃ©ralement d'un hÃ©ros, d'un monstre ou d'un PNJ (un personnage non joueur), mais pas par exemple, d'un objet statique comme un arbre.
- **self-destructing** Ces objets n'existent que pendant une pÃ©riode dÃ©finie avant d'Ãªtre configurÃ©s pour Ãªtre supprimÃ©s. Habituellement, cela est reprÃ©sentÃ© par un boolÃ©en `dead` ou `destroyed` qui signale au moteur de jeu que cet objet ne doit plus Ãªtre rendu.
- **cool-down** 'Cool-down' est une propriÃ©tÃ© typique parmi les objets Ã  courte durÃ©e de vie. Un exemple typique est un morceau de texte ou un effet graphique comme une explosion qui ne devrait Ãªtre vu que pendant quelques millisecondes.

âœ… Pensez Ã  un jeu comme Pac-Man. Pouvez-vous identifier les quatre types d'objets Ã©numÃ©rÃ©s ci-dessus dans ce jeu?

### Exprimer le comportement

Tout ce que nous avons dÃ©crit ci-dessus est le comportement que les objets du jeu peuvent avoir. Alors comment les encoder? Nous pouvons exprimer ce comportement sous forme de mÃ©thodes associÃ©es Ã  des classes ou Ã  des objets.

**Classes**

L'idÃ©e est d'utiliser des `classes` en conjonction avec l'`hÃ©ritage` pour accomplir l'ajout d'un certain comportement Ã  une classe.

âœ… L'hÃ©ritage est un concept important Ã  comprendre. En savoir plus sur l'[article de MDN sur l'hÃ©ritage](https://developer.mozilla.org/docs/Web/JavaScript/Inheritance_and_the_prototype_chain).

ExprimÃ© via du code, un objet de jeu peut gÃ©nÃ©ralement ressembler Ã  ceci:

```javascript

//configurer la classe GameObject
class GameObject {
  constructor(x, y, type) {
    this.x = x;
    this.y = y;
    this.type = type;
  }
}

//cette classe Ã©tendra les propriÃ©tÃ©s de classe inhÃ©rentes Ã  GameObject
class Movable extends GameObject {
  constructor(x,y, type) {
    super(x,y, type)
  }

//cet objet mobile peut Ãªtre dÃ©placÃ© sur l'Ã©cran
  moveTo(x, y) {
    this.x = x;
    this.y = y;
  }
}

//il s'agit d'une classe spÃ©cifique qui Ã©tend la classe Movable, afin qu'elle puisse profiter de toutes les propriÃ©tÃ©s dont elle hÃ©rite
class Hero extends Movable {
  constructor(x,y) {
    super(x,y, 'Hero')
  }
}

//cette classe, en revanche, n'hÃ©rite que des propriÃ©tÃ©s de GameObject
class Tree extends GameObject {
  constructor(x,y) {
    super(x,y, 'Tree')
  }
}

//un hÃ©ros peut bouger...
const hero = new Hero();
hero.moveTo(5,5);

//mais un arbre ne le peut pas
const tree = new Tree();
```

âœ… Prenez quelques minutes pour rÃ©imaginer un hÃ©ros de Pac-Man (Inky, Pinky ou Blinky, par exemple) et comment il serait Ã©crit en JavaScript.

**Composition**

Une autre maniÃ¨re de gÃ©rer l'hÃ©ritage d'objet consiste Ã  utiliser la *Composition*. Ensuite, les objets expriment leur comportement comme ceci:

```javascript
//crÃ©er un constant gameObject
const gameObject = {
  x: 0,
  y: 0,
  type: ''
};

//...et un constant movable
const movable = {
  moveTo(x, y) {
    this.x = x;
    this.y = y;
  }
}
//alors la constante mobileObject est composÃ©e du gameObject et des constantes mobiles
const movableObject = {...gameObject, ...movable};

//puis crÃ©ez une fonction pour crÃ©er un nouveau hÃ©ros qui hÃ©rite des propriÃ©tÃ©s mobileObject
function createHero(x, y) {
  return {
    ...movableObject,
    x,
    y,
    type: 'Hero'
  }
}
//...et un objet statique qui hÃ©rite uniquement des propriÃ©tÃ©s de gameObject
function createStatic(x, y, type) {
  return {
    ...gameObject
    x,
    y,
    type
  }
}
//crÃ©er le hÃ©ros et le dÃ©placer
const hero = createHero(10,10);
hero.moveTo(5,5);
//et crÃ©er un arbre statique qui ne se trouve que dans les environs
const tree = createStatic(0,0, 'Tree'); 
```

**Quel modÃ¨le dois-je utiliser?**

C'est Ã  vous de dÃ©cider quel modÃ¨le vous choisissez. JavaScript prend en charge ces deux paradigmes.

--

Un autre modÃ¨le courant dans le dÃ©veloppement de jeux aborde le problÃ¨me de la gestion de l'expÃ©rience utilisateur et des performances du jeu.

## ModÃ¨le Pub/sub

âœ… Pub/Sub signifie  'publish-subscribe' (publier-s'abonner en franÃ§ais)

Ce modÃ¨le rÃ©pond Ã  l'idÃ©e que les parties disparates de votre application ne devraient pas se connaÃ®tre. Pourquoi donc? Il est beaucoup plus facile de voir ce qui se passe en gÃ©nÃ©ral si diffÃ©rentes parties sont sÃ©parÃ©es. Cela facilite Ã©galement le changement soudain de comportement si vous en avez besoin. Comment accomplir cela? Pour ce faire, nous Ã©tablissons quelques concepts:

- **message**: Un message est gÃ©nÃ©ralement une chaÃ®ne de texte accompagnÃ©e d'une charge utile facultative (une donnÃ©e qui clarifie le sujet du message). Un message typique dans un jeu peut Ãªtre `KEY_PRESSED_ENTER`.
- **publisher**: Cet Ã©lÃ©ment *publie* un message et l'envoie Ã  tous les abonnÃ©s.
- **subscriber**: Cet Ã©lÃ©ment *Ã©coute* des messages spÃ©cifiques et exÃ©cute une tÃ¢che Ã  la suite de la rÃ©ception de ce message, comme tirer un laser.

L'implÃ©mentation est assez petite mais c'est un modÃ¨le trÃ¨s puissant. Voici comment cela peut Ãªtre mis en Å“uvre:

```javascript
//configurer une classe EventEmitter qui contient des Ã©couteurs
class EventEmitter {
  constructor() {
    this.listeners = {};
  }
//lorsqu'un message est reÃ§u, laissez l'auditeur gÃ©rer sa charge utile
  on(message, listener) {
    if (!this.listeners[message]) {
      this.listeners[message] = [];
    }
    this.listeners[message].push(listener);
  }
//lorsqu'un message est envoyÃ©, envoyez-le Ã  un auditeur avec une charge utile
  emit(message, payload = null) {
    if (this.listeners[message]) {
      this.listeners[message].forEach(l => l(message, payload))
    }
  }
}

```

Pour utiliser le code ci-dessus, nous pouvons crÃ©er une trÃ¨s petite implÃ©mentation:

```javascript
//mettre en place une structure de message
const Messages = {
  HERO_MOVE_LEFT: 'HERO_MOVE_LEFT'
};
//invoquez l'eventEmitter que vous avez configurÃ© ci-dessus
const eventEmitter = new EventEmitter();
//dÃ©finissez un hÃ©ros
const hero = createHero(0,0);
//faites savoir Ã  l'EventEmitter de surveiller les messages concernant le hÃ©ros qui se dÃ©place vers la gauche et agissez en consÃ©quence
eventEmitter.on(Messages.HERO_MOVE_LEFT, () => {
  hero.move(5,0);
});

//configurer la fenÃªtre pour Ã©couter l'Ã©vÃ©nement keyup, en particulier si la flÃ¨che gauche est touchÃ©e, Ã©mettre un message pour dÃ©placer le hÃ©ros vers la gauche
window.addEventListener('keyup', (evt) => {
  if (evt.key === 'ArrowLeft') {
    eventEmitter.emit(Messages.HERO_MOVE_LEFT)
  }
});
```

Ci-dessus, nous connectons un Ã©vÃ©nement de clavier, `ArrowLeft` et envoyons le message `HERO_MOVE_LEFT`. Nous Ã©coutons ce message et faisons bouger le `hero` en consÃ©quence. La force de ce modÃ¨le est que l'auditeur de l'Ã©vÃ©nement et le hÃ©ros ne se connaissent pas. Vous pouvez remapper la touche `ArrowLeft` sur la touche `A`. De plus, il serait possible de faire quelque chose de complÃ¨tement diffÃ©rent sur `ArrowLeft` en apportant quelques modifications Ã  la fonction `on` de l'eventEmitter:

```javascript
eventEmitter.on(Messages.HERO_MOVE_LEFT, () => {
  hero.move(5,0);
});
```

Au fur et Ã  mesure que les choses se compliquent lorsque votre jeu s'Ã©tend, ce modÃ¨le reste le mÃªme en complexitÃ© et votre code reste propre. Il est vraiment recommandÃ© d'adopter ce modÃ¨le.

---

## ğŸš€ Challenge

Pensez Ã  la faÃ§on dont le modÃ¨le pub-sub peut amÃ©liorer un jeu. Quelles parties doivent Ã©mettre des Ã©vÃ©nements, et comment le jeu doit-il y rÃ©agir? C'est maintenant votre chance de faire preuve de crÃ©ativitÃ©, en pensant Ã  un nouveau jeu et Ã  la faÃ§on dont ses parties pourraient se comporter.

## Quiz de validation des connaissances

[Quiz de validation des connaissancesz](https://ashy-river-0debb7803.1.azurestaticapps.net/quiz/30?loc=fr)

## RÃ©vision et Ã©tude personnelle

En savoir plus sur Pub/Sub en [lisant sur ce sujet](https://docs.microsoft.com/azure/architecture/patterns/publisher-subscriber/?WT.mc_id=academic-77807-sagibbon).

## Affectation

[Conception d'un jeu](assignment.fr.md)


export default ({ children }) => <div className="docs-content">{children}</div>;