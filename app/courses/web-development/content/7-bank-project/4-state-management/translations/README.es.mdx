---
title: Conceptos de gestiÃ³n del estado
description: Â¿QuÃ© problemas estamos realmente tratando de resolver aquÃ­?
lastUpdated: 2024-12-21T06:11:55.476Z
---

# Conceptos de gestiÃ³n del estado

## [Pre-lecture prueba](https://ashy-river-0debb7803.1.azurestaticapps.net/quiz/47)

### IntroducciÃ³n

A medida que una aplicaciÃ³n web crece, mantener un seguimiento limpio de todos los flujos de datos se convierte en un desafÃ­o. QuÃ© cÃ³digo obtiene los datos, quÃ© pÃ¡gina los consume, dÃ³nde y cuÃ¡ndo debe actualizarse, es fÃ¡cil terminar con un cÃ³digo desordenado y difÃ­cil de mantener. Esto es especialmente cierto cuando necesita compartir datos entre diferentes pÃ¡ginas de su aplicaciÃ³n, por ejemplo, los datos del usuario. El concepto de *gestiÃ³n estatal* siempre ha existido en todo tipo de programas, pero a medida que las aplicaciones web siguen creciendo en complejidad, ahora es un punto clave en el que pensar durante el desarrollo.

En esta parte final, revisaremos la aplicaciÃ³n que creamos para repensar cÃ³mo se administra el estado, lo que permite la compatibilidad con la actualizaciÃ³n del navegador en cualquier momento y la persistencia de datos en las sesiones de los usuarios.

### Requisito previo

Debe haber completado la parte [obtenciÃ³n de datos](../3-data/README.md) de la aplicaciÃ³n web para esta lecciÃ³n. TambiÃ©n necesita instalar [Node.js](https://nodejs.org) y [ejecutar la API del servidor](../api/README.md) localmente para poder administrar los datos de la cuenta.

Puede probar que el servidor estÃ¡ funcionando correctamente ejecutando este comando en una terminal:


```sh
curl http://localhost:5000/api
# -> debe devolver "API bancaria v1.0.0" como resultado
```

---

## Repensar la gestiÃ³n del estado

En la [lecciÃ³n anterior](../3-data/README.md), empezamos con un concepto bÃ¡sico de estado en nuestra aplicaciÃ³n con la variable global `account` que contiene los datos bancarios del usuario actualmente conectado. Sin embargo, nuestra implementaciÃ³n actual tiene algunas fallas. Intente actualizar la pÃ¡gina cuando estÃ© en el panel. Pero Â¿quÃ© pasa?

Hay 3 problemas con el cÃ³digo actual:

- El estado no persiste, ya que una actualizaciÃ³n del navegador lo lleva de regreso a la pÃ¡gina de inicio de sesiÃ³n.
- Hay mÃºltiples funciones que modifican el estado. A medida que la aplicaciÃ³n crece, puede dificultar el seguimiento de los cambios y es fÃ¡cil olvidarse de actualizar uno.
- El estado no se limpia, cuando hace clic en *Cerrar sesiÃ³n*, los datos de la cuenta siguen ahÃ­ aunque estÃ© en la pÃ¡gina de inicio de sesiÃ³n.

PodrÃ­amos actualizar nuestro cÃ³digo para abordar estos problemas uno por uno, pero crearÃ­a mÃ¡s duplicaciÃ³n de cÃ³digo y harÃ­a que la aplicaciÃ³n sea mÃ¡s compleja y difÃ­cil de mantener. O podrÃ­amos hacer una pausa por unos minutos y repensar nuestra estrategia.

> Â¿QuÃ© problemas estamos realmente tratando de resolver aquÃ­?

La [gestiÃ³n del estado](https://en.wikipedia.org/wiki/State_management) se trata de encontrar un buen enfoque para resolver estos dos problemas particulares:

- Â¿CÃ³mo mantener los flujos de datos en una aplicaciÃ³n fÃ¡ciles de entender?
- Â¿CÃ³mo mantener los datos de estado siempre sincronizados con la interfaz de usuario (y viceversa)?

Una vez que se haya ocupado de esto, es posible que cualquier otro problema que pueda tener ya estÃ© solucionado o que sea mÃ¡s fÃ¡cil de solucionar. Hay muchos enfoques posibles para resolver estos problemas, pero optaremos por una soluciÃ³n comÃºn que consiste en **centralizar los datos y las formas de cambiarlos**. Los flujos de datos serÃ­an asÃ­:

![](./images/data-flow.png)

> No cubriremos aquÃ­ la parte en la que los datos activan automÃ¡ticamente la actualizaciÃ³n de la vista, ya que estÃ¡ vinculada a conceptos mÃ¡s avanzados de [ProgramaciÃ³n reactiva](https://en.wikipedia.org/wiki/Reactive_programming). Es un buen tema de seguimiento si estÃ¡s preparado para una inmersiÃ³n profunda.

âœ… Hay muchas bibliotecas con diferentes enfoques para la administraciÃ³n del estado, [Redux](https://redux.js.org) es una opciÃ³n popular. Eche un vistazo a los conceptos y patrones utilizados, ya que a menudo es una buena manera de aprender quÃ© problemas potenciales puede enfrentar en aplicaciones web grandes y cÃ³mo se pueden resolver.

### Tarea

Comenzaremos con un poco de refactorizaciÃ³n. Reemplace la declaraciÃ³n `account`:

```js
let account = null;
```

Con:

```js
let state = {
  account: null
};
```

La idea es *centralizar* todos los datos de nuestra aplicaciÃ³n en un solo objeto de estado. Solo tenemos "cuenta" por ahora en el estado, por lo que no cambia mucho, pero crea un camino fÃ¡cil para las evoluciones.

TambiÃ©n tenemos que actualizar las funciones usÃ¡ndolo. En las funciones `register()` y `login()`, reemplace `account=...` con `state.account=...`;

En la parte superior de la funciÃ³n `updateDashboard()`, agregue esta lÃ­nea:

```js
const account = state.account;
```

Esta refactorizaciÃ³n por sÃ­ sola no trajo muchas mejoras, pero la idea era sentar las bases para los prÃ³ximos cambios.

## Seguimiento de cambios de datos

Ahora que hemos implementado el objeto `state` para almacenar nuestros datos, el siguiente paso es centralizar las actualizaciones. El objetivo es facilitar el seguimiento de los cambios y cuÃ¡ndo ocurren.

Para evitar que se realicen cambios en el objeto `state`, tambiÃ©n es una buena prÃ¡ctica considerarlo [*inmutable*](https://en.wikipedia.org/wiki/Immutable_object), lo que significa que no se puede modificar en absoluto. TambiÃ©n significa que debe crear un nuevo objeto de estado si desea cambiar algo en Ã©l. Al hacer esto, crea una protecciÃ³n contra [efectos secundarios](https://en.wikipedia.org/wiki/Side_effect_(computer_science)) potencialmente no deseados y abre posibilidades para nuevas funciones en su aplicaciÃ³n, como implementar deshacer / rehacer, al mismo tiempo que facilita la depuraciÃ³n. Por ejemplo, puede registrar todos los cambios realizados en el estado y mantener un historial de los cambios para comprender el origen de un error.

En JavaScript, puede usar [`Object.freeze()`](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze) para crear una versiÃ³n inmutable de un objeto. Si intenta realizar cambios en un objeto inmutable, se generarÃ¡ una excepciÃ³n.

âœ… Â¿Conoce la diferencia entre un objeto *superficial* y un objeto inmutable *profundo*? Puede leer sobre esto [aquÃ­](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze#What_is_shallow_freeze).

### Tarea

Creemos una nueva funciÃ³n `updateState()`:

```js
function updateState(property, newData) {
  state = Object.freeze({
    ...state,
    [property]: newData
  });
}
```

En esta funciÃ³n, estamos creando un nuevo objeto de estado y copiamos datos del estado anterior usando el operador [*spread (`...`)*](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/Spread_syntax#Spread_in_object_literals). Luego anulamos una propiedad particular del objeto de estado con los nuevos datos usando la [notaciÃ³n de corchetes](https://developer.mozilla.org/docs/Web/JavaScript/Guide/Working_with_Objects#Objects_and_properties) `[property]` para asignaciÃ³n. Finalmente, bloqueamos el objeto para evitar modificaciones usando `Object.freeze()`. Solo tenemos la propiedad `account` almacenada en el estado por ahora, pero con este enfoque puede agregar tantas propiedades como necesite en el estado.

TambiÃ©n actualizaremos la inicializaciÃ³n del `estado` para asegurarnos de que el estado inicial tambiÃ©n estÃ© congelado:

```js
let state = Object.freeze({
  account: null
});
```

DespuÃ©s de eso, actualice la funciÃ³n `register` reemplazando la asignaciÃ³n `state.account = result;` con:

```js
updateState('account', result);
```

Haz lo mismo con la funciÃ³n `login`, reemplazando `state.account = data;` con:

```js
updateState('account', data);
```

Ahora aprovecharemos la oportunidad para solucionar el problema de que los datos de la cuenta no se borran cuando el usuario hace clic en *Cerrar sesiÃ³n*.

Cree una nueva funciÃ³n `logout()`:

```js
function logout() {
  updateState('account', null);
  navigate('/login');
}
```

En `updateDashboard()`, reemplace la redirecciÃ³n `return navigate('/login');` por `return logout()`;

Intente registrar una nueva cuenta, cierre la sesiÃ³n y vuelva a iniciarla para comprobar que todo sigue funcionando correctamente.

> Consejo: puede echar un vistazo a todos los cambios de estado agregando `console.log(state)` en la parte inferior de `updateState()` y abriendo la consola en las herramientas de desarrollo de su navegador.

## Persiste el estado

La mayorÃ­a de las aplicaciones web necesitan conservar los datos para poder funcionar correctamente. Todos los datos crÃ­ticos generalmente se almacenan en una base de datos y se accede a ellos a travÃ©s de una API de servidor, como los datos de la cuenta de usuario en nuestro caso. Pero a veces, tambiÃ©n es interesante conservar algunos datos en la aplicaciÃ³n cliente que se ejecuta en su navegador, para una mejor experiencia de usuario o para mejorar el rendimiento de carga.

Cuando desee conservar los datos en su navegador, hay algunas preguntas importantes que debe hacerse:

- *Â¿Son los datos confidenciales?* Debe evitar almacenar datos confidenciales en el cliente, como contraseÃ±as de usuario.
- *Â¿Por cuÃ¡nto tiempo necesita conservar estos datos?* Â¿Planea acceder a estos datos solo para la sesiÃ³n actual o desea que se almacenen para siempre?

Hay varias formas de almacenar informaciÃ³n dentro de una aplicaciÃ³n web, dependiendo de lo que desee lograr. Por ejemplo, puede utilizar las URL para almacenar una consulta de bÃºsqueda y hacer que se pueda compartir entre los usuarios. TambiÃ©n puede utilizar [cookies HTTP](https://developer.mozilla.org/docs/Web/HTTP/Cookies) si los datos deben compartirse con el servidor, como [autenticaciÃ³n](https://en.wikipedia.org/wiki/Authentication) de la informaciÃ³n.

Otra opciÃ³n es utilizar una de las muchas API del navegador para almacenar datos. Dos de ellos son particularmente interesantes:

- [`localStorage`](https://developer.mozilla.org/docs/Web/API/Window/localStorage): un [almacÃ©n de claves / valores](https://en.wikipedia.org/wiki/Key%E2%80%93value_database) que permite conservar datos especÃ­ficos del sitio web actual en diferentes sesiones. Los datos guardados en Ã©l nunca caducan.
- [`sessionStorage`](https://developer.mozilla.org/docs/Web/API/Window/sessionStorage): este funciona igual que `localStorage` excepto que los datos almacenados en Ã©l se borran cuando finaliza la sesiÃ³n (cuando se cierra el navegador).

Tenga en cuenta que estas dos API solo permiten almacenar [cadenas](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String). Si desea almacenar objetos complejos, deberÃ¡ serializarlos al formato [JSON](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/JSON) usando [`JSON.stringify()`](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify).

âœ… Si desea crear una aplicaciÃ³n web que no funcione con un servidor, tambiÃ©n es posible crear una base de datos en el cliente usando la [API de IndexedDB](https://developer.mozilla.org/docs/Web/API/IndexedDB_API). Este estÃ¡ reservado para casos de uso avanzados o si necesita almacenar una cantidad significativa de datos, ya que es mÃ¡s complejo de usar.

### Tarea

Queremos que nuestros usuarios permanezcan conectados hasta que hagan clic explÃ­citamente en el botÃ³n *Cerrar sesiÃ³n*, por lo que usaremos `localStorage` para almacenar los datos de la cuenta. Primero, definamos una clave que usaremos para almacenar nuestros datos.

```js
const storageKey = 'savedAccount';
```

Luego agregue esta lÃ­nea al final de la funciÃ³n `updateState()`:

```js
localStorage.setItem(storageKey, JSON.stringify(state.account));
```

Con esto, los datos de la cuenta de usuario serÃ¡n persistentes y siempre actualizados ya que centralizamos previamente todas nuestras actualizaciones de estado. AquÃ­ es donde comenzamos a beneficiarnos de todas nuestras refactorizaciones anteriores ğŸ™‚.

A medida que se guardan los datos, tambiÃ©n tenemos que encargarnos de restaurarlos cuando se carga la aplicaciÃ³n. Ya que comenzaremos a tener mÃ¡s cÃ³digo de inicializaciÃ³n, puede ser una buena idea crear una nueva funciÃ³n `init`, que tambiÃ©n incluya nuestro cÃ³digo anterior al final de `app.js`:

```js
function init() {
  const savedAccount = localStorage.getItem(storageKey);
  if (savedAccount) {
    updateState('account', JSON.parse(savedAccount));
  }

  // Nuestro cÃ³digo de inicializaciÃ³n anterior
  window.onpopstate = () => updateRoute();
  updateRoute();
}

init();
```

AquÃ­ recuperamos los datos guardados y, si hay alguno, actualizamos el estado en consecuencia. Es importante hacer esto *antes* de actualizar la ruta, ya que puede haber un cÃ³digo que dependa del estado durante la actualizaciÃ³n de la pÃ¡gina.

TambiÃ©n podemos hacer que la pÃ¡gina *Panel de control* sea nuestra pÃ¡gina predeterminada de la aplicaciÃ³n, ya que ahora estamos conservando los datos de la cuenta. Si no se encuentran datos, el panel se encarga de redirigir a la pÃ¡gina *Iniciar sesiÃ³n* de todos modos. En `updateRoute()`, reemplace el respaldo `return navigate('/login');` con `return navigate('dashboard');`.

Ahora inicie sesiÃ³n en la aplicaciÃ³n e intente actualizar la pÃ¡gina, debe permanecer en el tablero. Con esa actualizaciÃ³n nos hemos ocupado de todos nuestros problemas iniciales ...

## Actualizar los datos

... Pero tambiÃ©n podrÃ­amos haber creado uno nuevo. Oups.

Vaya al panel de control con la cuenta `test`, luego ejecute este comando en una terminal para crear una nueva transacciÃ³n:

```sh
curl --request POST \
     --header "Content-Type: application/json" \
     --data "{ \"date\": \"2020-07-24\", \"object\": \"Bought book\", \"amount\": -20 }" \
     http://localhost:5000/api/accounts/test/transactions
```

Intente actualizar la pÃ¡gina del panel en el navegador ahora. Â¿QuÃ© ocurre? Â¿Ves la nueva transacciÃ³n?

El estado se conserva indefinidamente gracias al `localStorage`, pero eso tambiÃ©n significa que nunca se actualiza hasta que cierre la sesiÃ³n de la aplicaciÃ³n y vuelva a iniciarla.

Una posible estrategia para solucionarlo es volver a cargar los datos de la cuenta cada vez que se carga el panel, para evitar que se atasquen los datos.

### Tarea

Cree una nueva funciÃ³n `updateAccountData`:

```js
async function updateAccountData() {
  const account = state.account;
  if (!account) {
    return logout();
  }

  const data = await getAccount(account.user);
  if (data.error) {
    return logout();
  }

  updateState('account', data);
}
```

Este mÃ©todo comprueba que estamos conectados actualmente y luego vuelve a cargar los datos de la cuenta desde el servidor.

Cree otro nombre de funciÃ³n `refresh`:

```js
async function refresh() {
  await updateAccountData();
  updateDashboard();
}
```

Ã‰ste actualiza los datos de la cuenta, luego se encarga de actualizar el HTML de la pÃ¡gina del tablero. Es lo que necesitamos llamar cuando se carga la ruta del tablero. Actualice la definiciÃ³n de ruta con:

```js
const routes = {
  '/login': { templateId: 'login' },
  '/dashboard': { templateId: 'dashboard', init: refresh }
};
```

Intente volver a cargar el panel ahora, deberÃ­a mostrar los datos de la cuenta actualizados.

---

## ğŸš€ DesafÃ­o

Ahora que recargamos los datos de la cuenta cada vez que se carga el panel, Â¿cree que aÃºn necesitamos conservar *todos los datos de la cuenta*?

Intente trabajar juntos para cambiar lo que se guarda y carga desde `localStorage` para incluir solo lo que es absolutamente necesario para que la aplicaciÃ³n funcione.

## [Post-lecture prueba](https://ashy-river-0debb7803.1.azurestaticapps.net/quiz/48)

## AsignaciÃ³n

[Implementar el cuadro de diÃ¡logo "Agregar transacciÃ³n"](assignment.es.md)

AquÃ­ hay un ejemplo de resultado despuÃ©s de completar la tarea:

![Captura de pantalla que muestra un ejemplo de diÃ¡logo "Agregar transacciÃ³n"](../images/dialog.png)


export default ({ children }) => <div className="docs-content">{children}</div>;