---
title: CrÃ©er une application bancaire Partie 4: Concepts de gestion d'Ã©tat
description: Quels problÃ¨mes essayons-nous vraiment de rÃ©soudre ici?
lastUpdated: 2024-12-21T06:11:55.479Z
---

# CrÃ©er une application bancaire Partie 4: Concepts de gestion d'Ã©tat

## Quiz prÃ©alable

[Quiz prÃ©alable](https://ashy-river-0debb7803.1.azurestaticapps.net/quiz/47?loc=fr)

### Introduction

Au fur et Ã  mesure quâ€™une application Web se dÃ©veloppe, il devient difficile de suivre tous les flux de donnÃ©es. Quel code obtient les donnÃ©es, quelle page les consomme, oÃ¹ et quand doit-il Ãªtre mis Ã  jour... il est facile de se retrouver avec un code dÃ©sordonnÃ© et difficile Ã  maintenir. Cela est particuliÃ¨rement vrai lorsque vous devez partager des donnÃ©es entre diffÃ©rentes pages de votre application, par exemple des donnÃ©es utilisateur. Le concept de *gestion de lâ€™Ã©tat* a toujours existÃ© dans toutes sortes de programmes, mais comme les applications Web ne cessent de croÃ®tre en complexitÃ©, câ€™est maintenant un point clÃ© Ã  prendre en compte pendant le dÃ©veloppement.

Dans cette derniÃ¨re partie, nous examinerons lâ€™application que nous avons crÃ©Ã©e pour repenser la faÃ§on dont lâ€™Ã©tat est gÃ©rÃ©, permettant la prise en charge de lâ€™actualisation du navigateur Ã  tout moment et la persistance des donnÃ©es entre les sessions utilisateur.

### PrÃ©requis

Vous devez avoir terminÃ© la [rÃ©cupÃ©ration des donnÃ©es](../../3-data/translations/README.fr.md) de lâ€™application web pour cette leÃ§on. Vous devez Ã©galement installer [Node.js](https://nodejs.org) et [exÃ©cuter lâ€™API du serveur](../../api/translations/README.fr.md) localement afin que vous puissiez gÃ©rer les donnÃ©es du compte.

Vous pouvez tester que le serveur fonctionne correctement en exÃ©cutant cette commande dans un terminal:

```sh
curl http://localhost:5000/api
# -> doit renvoyer "Bank API v1.0.0" comme rÃ©sultat
```

---

## Repenser la gestion des Ã©tats

Dans la [leÃ§on prÃ©cÃ©dente](../../3-data/translations/README.fr.md), nous avons introduit un concept basique dâ€™Ã©tat dans notre application avec la variable globale `account` qui contient les donnÃ©es bancaires de lâ€™utilisateur actuellement connectÃ©. Cependant, notre mise en Å“uvre actuelle prÃ©sente certains dÃ©fauts. Essayez dâ€™actualiser la page lorsque vous Ãªtes sur le tableau de bord. Que se passe-t-il?

Il y a 3 problÃ¨mes avec le code actuel:

- Lâ€™Ã©tat nâ€™est pas persistant, car une actualisation du navigateur vous ramÃ¨ne Ã  la page de connexion.
- Il existe plusieurs fonctions qui modifient lâ€™Ã©tat. Au fur et Ã  mesure que lâ€™application se dÃ©veloppe, il peut Ãªtre difficile de suivre les modifications et il est facile dâ€™oublier dâ€™en mettre Ã  jour une.
- Lâ€™Ã©tat nâ€™est pas nettoyÃ©, donc lorsque vous cliquez sur *Logout* les donnÃ©es du compte sont toujours lÃ  mÃªme si vous Ãªtes sur la page de connexion.

Nous pourrions mettre Ã  jour notre code pour rÃ©soudre ces problÃ¨mes un par un, mais cela crÃ©erait plus de duplication de code et rendrait lâ€™application plus complexe et difficile Ã  maintenir. Ou nous pourrions faire une pause de quelques minutes et repenser notre stratÃ©gie.

> Quels problÃ¨mes essayons-nous vraiment de rÃ©soudre ici?

[La gestion de lâ€™Ã©tat](https://en.wikipedia.org/wiki/State_management) consiste Ã  trouver une bonne approche pour rÃ©soudre ces deux problÃ¨mes particuliers:

- Comment rendre comprÃ©hensibles les flux de donnÃ©es dans une application?
- Comment garder les donnÃ©es dâ€™Ã©tat toujours synchronisÃ©es avec lâ€™interface utilisateur (et vice versa)?

Une fois que vous vous Ãªtes occupÃ© de ceux-ci, tous les autres problÃ¨mes que vous pourriez avoir peuvent Ãªtre dÃ©jÃ  rÃ©solus ou sont devenus plus faciles Ã  rÃ©soudre. Il existe de nombreuses approches possibles pour rÃ©soudre ces problÃ¨mes, mais nous opterons pour une solution commune qui consiste Ã  **centraliser les donnÃ©es et les moyens de les modifier**. Les flux de donnÃ©es se dÃ©rouleraient comme suit:

![SchÃ©ma montrant les flux de donnÃ©es entre le code HTML, les actions de lâ€™utilisateur et lâ€™Ã©tat](../images/data-flow.png)

> Nous ne couvrirons pas ici la partie oÃ¹ les donnÃ©es dÃ©clenchent automatiquement la mise Ã  jour de la vue, car elle est liÃ©e Ã  des concepts plus avancÃ©s de [Programmation rÃ©active](https://en.wikipedia.org/wiki/Reactive_programming). Câ€™est un bon sujet de suivi si vous Ãªtes prÃªt Ã  plonger profondÃ©ment.

âœ… Il existe de nombreuses bibliothÃ¨ques avec diffÃ©rentes approches de la gestion des Ã‰tats, [Redux](https://redux.js.org) Ã©tant une option populaire. Jetez un coup dâ€™Å“il aux concepts et aux modÃ¨les utilisÃ©s, car câ€™est souvent un bon moyen dâ€™apprendre quels problÃ¨mes potentiels vous pouvez rencontrer dans les grandes applications Web et comment ils peuvent Ãªtre rÃ©solus.

### TÃ¢che

Nous allons commencer par un peu de refactorisation. Remplacer la dÃ©claration `account`:

```js
let account = null;
```

Par:

```js
let state = {
  account: null
};
```

Lâ€™idÃ©e est de *centraliser* toutes nos donnÃ©es dâ€™application dans un seul objet dâ€™Ã©tat. Nous nâ€™avons que le `account` pour lâ€™instant dans lâ€™Ã©tat, donc cela ne change pas beaucoup, mais cela crÃ©e un chemin pour les Ã©volutions.

Nous devons Ã©galement mettre Ã  jour les fonctions en lâ€™utilisant. Dans les fonctions `register()` et `login()`, remplacez `account = ...` par `state.account = ...`;

En haut de la fonction `updateDashboard()`, ajoutez cette ligne:

```js
const account = state.account;
```

Ce refactoring en lui-mÃªme nâ€™a pas apportÃ© beaucoup dâ€™amÃ©liorations, mais lâ€™idÃ©e Ã©tait de jeter les bases des prochains changements.

## Suivre les modifications de donnÃ©es

Maintenant que nous avons mis en place lâ€™objet `state` pour stocker nos donnÃ©es, lâ€™Ã©tape suivante consiste Ã  centraliser les mises Ã  jour. Lâ€™objectif est de faciliter le suivi des changements et de leur moment.

Pour Ã©viter que des modifications soient apportÃ©es Ã  lâ€™objet `state`, il est Ã©galement recommandÃ© de le considÃ©rer comme [*immuable*](https://en.wikipedia.org/wiki/Immutable_object), ce qui signifie quâ€™il ne peut pas Ãªtre modifiÃ© du tout. Cela signifie Ã©galement que vous devez crÃ©er un nouvel objet dâ€™Ã©tat si vous souhaitez y modifier quoi que ce soit. Ce faisant, vous crÃ©ez une protection contre les [effets secondaires](https://en.wikipedia.org/wiki/Side_effect_(computer_science)) potentiellement indÃ©sirables et ouvrez des possibilitÃ©s de nouvelles fonctionnalitÃ©s dans votre application, telles que la mise en Å“uvre de lâ€™annulation/rÃ©tablissement, tout en facilitant le dÃ©bogage. Par exemple, vous pouvez consigner chaque modification apportÃ©e Ã  lâ€™Ã©tat et conserver un historique des modifications pour comprendre la source dâ€™un bogue.

En JavaScript, vous pouvez utiliser [`Object.freeze()`](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze) pour crÃ©er une version immuable dâ€™un objet. Si vous essayez dâ€™apporter des modifications Ã  un objet immuable, une exception sera dÃ©clenchÃ©e.

âœ… Connaissez-vous la diffÃ©rence entre un objet immuable *peu profond* et un objet immuable *profond*? Vous pouvez en apprendre plus sur ce sujet [ici](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze#What_is_shallow_freeze).

### TÃ¢che

CrÃ©ons une nouvelle fonction `updateState()`:

```js
function updateState(property, newData) {
  state = Object.freeze({
    ...state,
    [property]: newData
  });
}
```

Dans cette fonction, nous crÃ©ons un nouvel objet dâ€™Ã©tat et copions les donnÃ©es de lâ€™Ã©tat prÃ©cÃ©dent Ã  lâ€™aide de [*lâ€™opÃ©rateur spread (`...`)*](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/Spread_syntax#Spread_in_object_literals). Ensuite, nous remplaÃ§ons une propriÃ©tÃ© particuliÃ¨re de lâ€™objet dâ€™Ã©tat par les nouvelles donnÃ©es en utilisant la [notation entre crochets](https://developer.mozilla.org/docs/Web/JavaScript/Guide/Working_with_Objects#Objects_and_properties) `[property]` pour lâ€™affectation. Enfin, nous verrouillons lâ€™objet pour empÃªcher les modifications en utilisant `Object.freeze()`. Nous nâ€™avons que la propriÃ©tÃ© `account` stockÃ©e dans lâ€™Ã©tat pour lâ€™instant, mais avec cette approche, vous pouvez ajouter autant de propriÃ©tÃ©s que nÃ©cessaire dans lâ€™Ã©tat.

Nous allons Ã©galement mettre Ã  jour lâ€™initialisation `state` pour nous assurer que lâ€™Ã©tat initial est Ã©galement gelÃ©:

```js
let state = Object.freeze({
  account: null
});
```

AprÃ¨s cela, mettez Ã  jour la fonction `register` en remplaÃ§ant lâ€™affectation `state.account = result;` par:

```js
updateState('account', result);
```

Faites de mÃªme avec la fonction `login`, en remplaÃ§ant `state.account = data;` par:

```js
updateState('account', data);
```

Nous allons maintenant saisir lâ€™occasion de rÃ©soudre le problÃ¨me des donnÃ©es de compte qui ne sont pas effacÃ©es lorsque lâ€™utilisateur clique sur *Logout*.

CrÃ©ez une nouvelle fonction `logout()`:

```js
function logout() {
  updateState('account', null);
  navigate('/login');
}
```

Dans `updateDashboard()`, remplacez la redirection `return navigate('/login');` par `return logout()`;

Essayez dâ€™enregistrer un nouveau compte, de vous dÃ©connecter et de vous reconnecter pour vÃ©rifier que tout fonctionne toujours correctement.

> Conseil: vous pouvez jeter un coup dâ€™Å“il Ã  tous les changements dâ€™Ã©tat en ajoutant `console.log(state)` au bas de `updateState()` et en ouvrant la console dans les outils de dÃ©veloppement de votre navigateur.

## Conserver lâ€™Ã©tat

La plupart des applications Web doivent conserver les donnÃ©es pour pouvoir fonctionner correctement. Toutes les donnÃ©es critiques sont gÃ©nÃ©ralement stockÃ©es dans une base de donnÃ©es et accessibles via une API de serveur, comme les donnÃ©es du compte utilisateur dans notre cas. Mais parfois, il est Ã©galement intÃ©ressant de conserver certaines donnÃ©es sur lâ€™application cliente qui sâ€™exÃ©cute dans votre navigateur, pour une meilleure expÃ©rience utilisateur ou pour amÃ©liorer les performances de chargement.

Lorsque vous souhaitez conserver des donnÃ©es dans votre navigateur, vous devez vous poser quelques questions importantes:

- *Les donnÃ©es sont-elles sensibles?* Vous devez Ã©viter de stocker des donnÃ©es sensibles sur le client, telles que les mots de passe des utilisateurs.
- *Pendant combien de temps devez-vous conserver ces donnÃ©es?* PrÃ©voyez-vous dâ€™accÃ©der Ã  ces donnÃ©es uniquement pour la session en cours ou souhaitez-vous quâ€™elles soient stockÃ©es pour toujours?

Il existe plusieurs faÃ§ons de stocker des informations dans une application web, en fonction de ce que vous souhaitez rÃ©aliser. Par exemple, vous pouvez utiliser les URL pour stocker une requÃªte de recherche et la rendre partageable entre les utilisateurs. Vous pouvez Ã©galement utiliser des [cookies HTTP](https://developer.mozilla.org/docs/Web/HTTP/Cookies) si les donnÃ©es doivent Ãªtre partagÃ©es avec le serveur, comme les informations d'[authentification](https://en.wikipedia.org/wiki/Authentication).

Une autre option consiste Ã  utiliser lâ€™une des nombreuses API de navigateur pour stocker des donnÃ©es. Deux dâ€™entre eux sont particuliÃ¨rement intÃ©ressants:

- [`localStorage`](https://developer.mozilla.org/docs/Web/API/Window/localStorage): un [Key/Value store](https://en.wikipedia.org/wiki/Key%E2%80%93value_database) permettant de conserver des donnÃ©es spÃ©cifiques au site web actuel sur diffÃ©rentes sessions. Les donnÃ©es qui y sont enregistrÃ©es nâ€™expirent jamais.
- [`sessionStorage`](https://developer.mozilla.org/docs/Web/API/Window/sessionStorage): celui-ci fonctionne de la mÃªme maniÃ¨re que `localStorage` sauf que les donnÃ©es qui y sont stockÃ©es sont effacÃ©es Ã  la fin de la session (lorsque le navigateur est fermÃ©).

Notez que ces deux API autorisent uniquement le stockage de [chaÃ®nes](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String). Si vous souhaitez stocker des objets complexes, vous devrez les sÃ©rialiser au format [JSON](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/JSON) Ã  lâ€™aide de [`JSON.stringify()`](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify).

âœ… Si vous souhaitez crÃ©er une application web qui ne fonctionne pas avec un serveur, il est Ã©galement possible de crÃ©er une base de donnÃ©es sur le client Ã  lâ€™aide de [lâ€™API `IndexedDB`](https://developer.mozilla.org/docs/Web/API/IndexedDB_API). Celui-ci est rÃ©servÃ© aux cas dâ€™utilisation avancÃ©s ou si vous avez besoin de stocker une quantitÃ© importante de donnÃ©es, car il est plus complexe Ã  utiliser.

### TÃ¢che

Nous voulons que nos utilisateurs restent connectÃ©s jusquâ€™Ã  ce quâ€™ils cliquent explicitement sur le bouton *Logout*, nous utiliserons donc `localStorage` pour stocker les donnÃ©es du compte. Tout dâ€™abord, dÃ©finissons une clÃ© que nous utiliserons pour stocker nos donnÃ©es.

```js
const storageKey = 'savedAccount';
```

Ajoutez ensuite cette ligne Ã  la fin de la fonction `updateState()`:

```js
localStorage.setItem(storageKey, JSON.stringify(state.account));
```

Avec cela, les donnÃ©es du compte utilisateur seront conservÃ©es et toujours Ã  jour car nous avons centralisÃ© prÃ©cÃ©demment toutes nos mises Ã  jour dâ€™Ã©tat. Câ€™est lÃ  que nous commenÃ§ons Ã  bÃ©nÃ©ficier de tous nos refactors prÃ©cÃ©dents ğŸ™‚.

Au fur et Ã  mesure que les donnÃ©es sont enregistrÃ©es, nous devons Ã©galement nous occuper de les restaurer lorsque lâ€™application est chargÃ©e. Puisque nous allons commencer Ã  avoir plus de code dâ€™initialisation, il peut Ãªtre judicieux de crÃ©er une nouvelle fonction `init`, qui inclut Ã©galement notre code prÃ©cÃ©dent au bas de `app.js`:

```js
function init() {
  const savedAccount = localStorage.getItem(storageKey);
  if (savedAccount) {
    updateState('account', JSON.parse(savedAccount));
  }

  // Notre prÃ©cÃ©dent code d'initialisation
  window.onpopstate = () => updateRoute();
  updateRoute();
}

init();
```

Ici, nous rÃ©cupÃ©rons les donnÃ©es enregistrÃ©es, et sâ€™il y en a, nous mettons Ã  jour lâ€™Ã©tat en consÃ©quence. Il est important de le faire *avant* de mettre Ã  jour lâ€™itinÃ©raire, car il peut y avoir du code sâ€™appuyant sur lâ€™Ã©tat lors de la mise Ã  jour de la page.

Nous pouvons Ã©galement faire de la page *Dashboard* notre page par dÃ©faut de lâ€™application, car nous conservons maintenant les donnÃ©es du compte. Si aucune donnÃ©e nâ€™est trouvÃ©e, le tableau de bord se charge de rediriger vers la page *Login* de toute faÃ§on. Dans `updateRoute()`, remplacez le secours `return navigate('/login');` par `return navigate('/dashboard');`.

Maintenant, connectez-vous Ã  lâ€™application et essayez dâ€™actualiser la page. Vous devez rester sur le tableau de bord. Avec cette mise Ã  jour, nous avons rÃ©solu tous nos problÃ¨mes initiaux...

## Actualiser les donnÃ©es

... Mais nous pourrions aussi en avoir crÃ©Ã© un nouveau. Oups!

AccÃ©dez au tableau de bord Ã  lâ€™aide du compte `test`, puis exÃ©cutez cette commande sur un terminal pour crÃ©er une nouvelle transaction:

```sh
curl --request POST \
     --header "Content-Type: application/json" \
     --data "{ \"date\": \"2020-07-24\", \"object\": \"Bought book\", \"amount\": -20 }" \
     http://localhost:5000/api/accounts/test/transactions
```

Essayez dâ€™actualiser la page du tableau de bord dans le navigateur maintenant. Que se passe-t-il? Voyez-vous la nouvelle transaction?

Lâ€™Ã©tat est conservÃ© indÃ©finiment grÃ¢ce au `localStorage`, mais cela signifie Ã©galement quâ€™il nâ€™est jamais mis Ã  jour tant que vous ne vous dÃ©connectez pas de lâ€™application et que vous ne vous connectez pas Ã  nouveau!

Une stratÃ©gie possible pour rÃ©soudre ce problÃ¨me consiste Ã  recharger les donnÃ©es du compte chaque fois que le tableau de bord est chargÃ©, afin dâ€™Ã©viter les donnÃ©es de blocage.

### TÃ¢che

CrÃ©ez une nouvelle fonction `updateAccountData`:

```js
async function updateAccountData() {
  const account = state.account;
  if (!account) {
    return logout();
  }

  const data = await getAccount(account.user);
  if (data.error) {
    return logout();
  }

  updateState('account', data);
}
```

Cette mÃ©thode vÃ©rifie que nous sommes actuellement connectÃ©s puis recharge les donnÃ©es du compte Ã  partir du serveur.

CrÃ©ez une autre fonction nommÃ©e `refresh`:

```js
async function refresh() {
  await updateAccountData();
  updateDashboard();
}
```

Celui-ci met Ã  jour les donnÃ©es du compte, puis se charge de mettre Ã  jour le code HTML de la page du tableau de bord. Câ€™est ce que nous devons appeler lorsque lâ€™itinÃ©raire du tableau de bord est chargÃ©. Mettez Ã  jour la dÃ©finition dâ€™itinÃ©raire avec:

```js
const routes = {
  '/login': { templateId: 'login' },
  '/dashboard': { templateId: 'dashboard', init: refresh }
};
```

Essayez de recharger le tableau de bord maintenant, il devrait afficher les donnÃ©es de compte mises Ã  jour.

---

## ğŸš€ Challenge

Maintenant que nous rechargeons les donnÃ©es du compte chaque fois que le tableau de bord est chargÃ©, pensez-vous que nous devons encore conserver *toutes les donnÃ©es du compte*?

Essayez de travailler ensemble pour modifier ce qui est enregistrÃ© et chargÃ© Ã  partir de `localStorage` pour nâ€™inclure que ce qui est absolument nÃ©cessaire pour que lâ€™application fonctionne.

## Quiz de validation des connaissances

[Quiz de validation des connaissances](https://ashy-river-0debb7803.1.azurestaticapps.net/quiz/48?loc=fr)

## Affectation

[ImplÃ©menter la boÃ®te de dialogue "Ajouter une transaction"](assignment.fr.md)

Voici un exemple de rÃ©sultat aprÃ¨s avoir terminÃ© lâ€™affectation:

![Capture dâ€™Ã©cran montrant un exemple de boÃ®te de dialogue "Ajouter une transaction"](../images/dialog.png)


export default ({ children }) => <div className="docs-content">{children}</div>;